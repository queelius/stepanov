// Algebraic Innovations Demo
// Showcases unique algebraic structures and algorithms

#include <iostream>
#include <complex>
#include <vector>
#include <iomanip>
#include <stepanov/polynomial.hpp>
#include <stepanov/groups.hpp>
#include <stepanov/tropical.hpp>
#include <stepanov/padic.hpp>
#include <stepanov/boolean_algebra.hpp>
#include <stepanov/algebraic_hashing.hpp>
#include <stepanov/fft.hpp>

using namespace stepanov;
using namespace std;

int main() {
    cout << "=== Algebraic Innovations Demo ===\n\n";

    // 1. Polynomial Arithmetic
    cout << "1. POLYNOMIAL ARITHMETIC\n";
    cout << "-----------------------\n";

    polynomial<double> p1({1, 2, 1});  // x^2 + 2x + 1
    polynomial<double> p2({1, -1});    // x - 1

    cout << "p1(x) = x² + 2x + 1\n";
    cout << "p2(x) = x - 1\n\n";

    auto product = p1 * p2;
    cout << "p1 × p2 = ";
    for (size_t i = 0; i < product.degree() + 1; ++i) {
        if (i > 0) cout << " + ";
        cout << product[i];
        if (i > 0) cout << "x";
        if (i > 1) cout << "^" << i;
    }
    cout << "\n";

    // Polynomial evaluation
    double x = 2.0;
    cout << "p1(" << x << ") = " << p1.evaluate(x) << "\n";

    // Newton's method for root finding
    auto root = p1.find_root(0.0);  // Starting guess
    cout << "Root of p1 near 0: x = " << root << "\n";
    cout << "Verify: p1(" << root << ") = " << p1.evaluate(root) << " ≈ 0\n\n";

    // 2. Group Theory
    cout << "2. GROUP THEORY\n";
    cout << "---------------\n";

    // Permutation group
    permutation_group S3(3);  // Symmetric group S₃

    cout << "Symmetric group S₃ (permutations of 3 elements):\n";
    cout << "  Order: " << S3.order() << "\n";
    cout << "  Elements: ";
    for (const auto& perm : S3.elements()) {
        cout << perm << " ";
    }
    cout << "\n";

    // Check group axioms
    cout << "  Closed under composition: " << (S3.is_closed() ? "✓" : "✗") << "\n";
    cout << "  Has identity: " << (S3.has_identity() ? "✓" : "✗") << "\n";
    cout << "  Every element has inverse: " << (S3.has_inverses() ? "✓" : "✗") << "\n";

    // Cyclic subgroup
    auto generator = S3.elements()[2];
    auto subgroup = S3.cyclic_subgroup(generator);
    cout << "  Cyclic subgroup generated by " << generator << ": ";
    cout << "order " << subgroup.order() << "\n\n";

    // 3. Tropical Mathematics
    cout << "3. TROPICAL MATHEMATICS\n";
    cout << "----------------------\n";
    cout << "(min, +) algebra - useful in optimization:\n\n";

    tropical<double> a(5.0);
    tropical<double> b(3.0);
    tropical<double> c(7.0);

    cout << "In tropical algebra:\n";
    cout << "  a = " << a.value << ", b = " << b.value << ", c = " << c.value << "\n";
    cout << "  a ⊕ b (min) = " << (a + b).value << "\n";
    cout << "  a ⊗ b (addition) = " << (a * b).value << "\n";

    // Tropical matrix for shortest paths
    cout << "\nTropical matrix multiplication finds shortest paths:\n";

    tropical_matrix<double> dist(3, 3);
    dist(0, 1) = tropical<double>(4.0);
    dist(0, 2) = tropical<double>(7.0);
    dist(1, 2) = tropical<double>(2.0);

    auto dist2 = dist * dist;  // 2-hop distances
    cout << "  Direct distance 0→2: " << dist(0, 2).value << "\n";
    cout << "  2-hop distance 0→1→2: " << dist2(0, 2).value << "\n";
    cout << "  Finds shortest path automatically!\n\n";

    // 4. p-adic Numbers
    cout << "4. P-ADIC NUMBERS\n";
    cout << "-----------------\n";
    cout << "Alternative number system (useful in number theory):\n\n";

    padic<5> x(27);  // 27 in 5-adic
    padic<5> y(13);  // 13 in 5-adic

    cout << "5-adic arithmetic:\n";
    cout << "  27 = " << x << " (base 5)\n";
    cout << "  13 = " << y << " (base 5)\n";
    cout << "  27 + 13 = " << (x + y) << "\n";
    cout << "  27 × 13 = " << (x * y) << "\n";

    // p-adic valuation
    cout << "  5-adic valuation of 125: " << padic<5>::valuation(125) << "\n";
    cout << "  (how many times 5 divides 125)\n\n";

    // 5. Boolean Algebra
    cout << "5. BOOLEAN ALGEBRA\n";
    cout << "------------------\n";

    boolean_expr a_var("a");
    boolean_expr b_var("b");
    boolean_expr c_var("c");

    auto expr = (a_var & b_var) | (~a_var & c_var);

    cout << "Expression: (a ∧ b) ∨ (¬a ∧ c)\n\n";

    cout << "Truth table:\n";
    cout << "a b c | result\n";
    cout << "------+-------\n";
    for (int mask = 0; mask < 8; ++mask) {
        bool a = mask & 4, b = mask & 2, c = mask & 1;
        bool result = expr.evaluate({{"a", a}, {"b", b}, {"c", c}});
        cout << a << " " << b << " " << c << " | " << result << "\n";
    }

    // Simplification
    auto simplified = expr.simplify();
    cout << "\nSimplified form: " << simplified << "\n\n";

    // 6. Algebraic Hashing
    cout << "6. ALGEBRAIC HASHING\n";
    cout << "--------------------\n";
    cout << "Hash functions with algebraic properties:\n\n";

    rolling_hash rh;
    string text = "abracadabra";

    cout << "Rolling hash of \"" << text << "\":\n";

    // Initial hash
    for (char c : text.substr(0, 5)) {
        rh.push(c);
    }
    cout << "  \"abrac\": " << rh.hash() << "\n";

    // Roll the hash
    rh.roll(text[5]);
    cout << "  \"braca\": " << rh.hash() << " (rolled)\n";

    // Polynomial hashing for strings
    polynomial_hash<> ph;
    cout << "\nPolynomial hashing:\n";
    cout << "  hash(\"test\") = " << ph("test") << "\n";
    cout << "  hash(\"testing\") = " << ph("testing") << "\n";

    // Matrix hashing (for 2D patterns)
    matrix_hash mh;
    vector<vector<int>> pattern = {{1,2}, {3,4}};
    cout << "\nMatrix hash of [[1,2],[3,4]]: " << mh(pattern) << "\n\n";

    // 7. FFT and Convolution
    cout << "7. FFT AND CONVOLUTION\n";
    cout << "---------------------\n";

    vector<complex<double>> signal1 = {{1,0}, {2,0}, {3,0}, {4,0}};
    vector<complex<double>> signal2 = {{1,0}, {1,0}, {0,0}, {0,0}};

    // FFT
    auto fft1 = fft(signal1);
    cout << "FFT of [1, 2, 3, 4]:\n";
    for (const auto& c : fft1) {
        cout << "  " << fixed << setprecision(2) << c << "\n";
    }

    // Convolution via FFT (O(n log n) instead of O(n²))
    auto conv = convolution(signal1, signal2);
    cout << "\nConvolution [1,2,3,4] * [1,1,0,0]:\n  ";
    for (const auto& c : conv) {
        cout << c.real() << " ";
    }
    cout << "\n\n";

    cout << "Key Insight: These algebraic structures enable\n";
    cout << "algorithms that would be impossible or inefficient\n";
    cout << "with traditional number systems!\n";

    return 0;
}